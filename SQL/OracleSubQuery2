--상관쿼리
--상호 연관되어 있는 쿼리. 기존의 쿼리는 서브 쿼리 실행 후 메인 쿼리가 실행되었으나, 상관 쿼리는 서로가 영향을 미치게 됨
--예제) 관리자가 있는 사원들 중, 관리자 사번이 EMPLOYEE 테이블에 존재하는 직원의 사번인 직원의 사번과 이름, 소속부서, 관리자 사번

SELECT * FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, MANAGER_ID
FROM EMPLOYEE E
WHERE EXISTS 
(SELECT EMP_ID FROM EMPLOYEE M WHERE E.MANAGER_ID = M.EMP_ID);
--이전에 사용하던 쿼리는 서브쿼리 내에 조건들이 독단적으로 수행되었던 것. 하지만 상관쿼리에서는 E.MANAGER_ID = M.EMP_ID 구문에서 메인 쿼리의 EMP_ID를 불러오게 된다.

--인사관리부, 회계관리부, 마케팅부서이면서 부서코드가 일치하는 사람들의 이름, 부서, 급여 출력. 
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE E
WHERE EXISTS (SELECT NULL
                    FROM DEPARTMENT D
                    WHERE D.DEPT_TITLE IN ('인사관리부', '회계관리부', '마케팅부') AND E.DEPT_CODE = D.DEPT_ID);
                    --NULL을 넣는 것은 항상 존재할 것이기 때문에 사용. 조인을 사용하지 않아도 되는 장점이 있다.
                    --아래 조인과 같은 결과를 출력

SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE DEPT_TITLE IN ('인사관리부', '회계관리부', '마케팅부')
ORDER BY 1;

-- 모든 사원의 사번, 이름, 관리자 사번, 관리자 이름 출력. 관리자 이름이 없는 경우, 없음으로 표현
-- JOIN 연습
SELECT
    E1.EMP_ID 사번,
    E1.EMP_NAME 이름,
    E1.MANAGER_ID 관리자사번,
    NVL(E2.EMP_ID, '없음') 관리자이름
FROM
    EMPLOYEE E1
LEFT JOIN EMPLOYEE E2 ON (E1.MANAGER_ID = E2.EMP_ID);

--스칼라 서브 쿼리 (SUB QUERY를 위치에 상관 없이 씀)
SELECT
    E1.EMP_ID 사번,
    E1.EMP_NAME 이름,
    E1.MANAGER_ID 관리자사번,
    NVL((SELECT E2.EMP_NAME FROM EMPLOYEE E2 WHERE E1.MANAGER_ID = E2.EMP_ID), '없음') 관리자이름
FROM
    EMPLOYEE E1;

-- 스칼라 서브쿼리 where절
-- 자신이 속한 직급의 평균 급여보다 많이 받는 직원의 이름, 직급코드, 급여

SELECT 
    EMP_NAME 이름,
    JOB_CODE 직급코드,
    SALARY 급여
FROM 
    EMPLOYEE E1
WHERE SALARY >= (SELECT AVG(SALARY)
                            FROM EMPLOYEE E2
                            WHERE E1.JOB_CODE = E2.JOB_CODE);

-- 스칼라 서브 쿼리 ORDER BY절
-- 직원의 사번, 이름, 부서코드를 출력
-- 부서명으로 내림차순 정렬

SELECT
    EMP_ID,
    EMP_NAME,
    DEPT_CODE
FROM EMPLOYEE
ORDER BY (SELECT DEPT_TITLE
                FROM DEPARTMENT 
                WHERE DEPT_CODE = DEPT_ID) DESC NULLS LAST;

-- 스칼라 서브 쿼리 FROM절 (인라인 뷰) 가상의 테이블로 넣어줌
-- 직원들 중 급여를 갖아 많이 받는 사원을 순서대로 5명 (ROWNUM : 순서대로 번호를 매겨줌)
SELECT ROWNUM, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE ROWNUM<=5
ORDER BY SALARY DESC; --SELECT가 끝난 후 정렬이 시작됨. ROWNUM, ORDER BY는.

SELECT ROWNUM, EMP_NAME, SALARY
FROM (SELECT * FROM EMPLOYEE ORDER BY SALARY DESC) -- 가상의 테이블을 만들어준다!
WHERE ROWNUM<=5; --정렬을 먼저 하고 5번째까지 자른다.

--그렇다면 동률 처리는 어떻게 할까?
-- (1)  RANK() OVER : 공동 19등을 만들어냄. 동률은 공동으로 처리. 19등 2명 다음은 21등으로 처리
SELECT 순위, EMP_NAME, SALARY
FROM (SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) AS 순위 FROM EMPLOYEE);

-- (2) DENSE_RANK() OVER : 공동 19등을 만들어냄. 동률은 공동으로 처리. 19등 2명 다음은 20등으로 처리
SELECT 순위, EMP_NAME, SALARY
FROM (SELECT EMP_NAME, SALARY, DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 순위 FROM EMPLOYEE);

-- (3) ROW_NUMBER() OVER : 동률은 공동으로 처리하지 않음. 같은 점수여도 19, 20으로 만듬
SELECT 순위, EMP_NAME, SALARY
FROM (SELECT EMP_NAME, SALARY, ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS 순위 FROM EMPLOYEE);

---SUB QUERY 실습 문제
-- (1) 기술지원부에 속한 사람들의 사람의 이름, 부서코드, 급여를 출력하시오
SELECT
    EMP_NAME,
    DEPT_CODE,
    SALARY
FROM
    EMPLOYEE
WHERE
    DEPT_CODE IN (SELECT DEPT_ID
                        FROM DEPARTMENT
                        WHERE DEPT_TITLE = '기술지원부');

-- (2) 기술지원부에 속한 사람들 중 가장 연봉이 높은 사람의 이름, 부서코드, 급여 출력
SELECT
    EMP_NAME,
    DEPT_CODE,
    SALARY 
FROM
    EMPLOYEE
WHERE
    SALARY IN (SELECT MAX(SALARY)
                    FROM EMPLOYEE
                    WHERE DEPT_CODE IN (SELECT DEPT_ID
                                                   FROM DEPARTMENT
                                                   WHERE DEPT_TITLE = '기술지원부'));
                                                   
SELECT *
FROM (SELECT EMP_NAME, DEPT_CODE, SALARY
        FROM EMPLOYEE
        WHERE DEPT_CODE = (SELECT DEPT_ID
                                        FROM DEPARTMENT
                                        WHERE DEPT_TITLE = '기술지원부')
        ORDER BY SALARY DESC)
WHERE ROWNUM = 1;

-- (3) 매니저가 있는 사원 중에 월급이 전체 사원 평균을 넘는 사원의 사번, 이름, 매니저 이름, 월급( 만원단위부터)을 구하시오
SELECT 
    E1.EMP_ID 사번,
    E1.EMP_NAME 이름,
    (SELECT EMP_NAME FROM EMPLOYEE E2 WHERE E1.MANAGER_ID=E2.EMP_ID) AS 매니저이름,
    TRUNC(E1.SALARY, -4) 월급
FROM
    EMPLOYEE E1
WHERE
    MANAGER_ID IS NOT NULL AND
    SALARY >= (SELECT AVG(SALARY)
                    FROM EMPLOYEE);
                    
                    
-- (4) 각 직급마다 급여 등급이 가장 높은 직원의 이름, 직급코드, 급여, 급여등급 조회
SELECT * FROM SAL_GRADE; --S1>S6
SELECT * FROM JOB;
SELECT * FROM EMPLOYEE;

SELECT 
    EMP_NAME,
    JOB_CODE,
    SALARY,
    SAL_LEVEL
FROM EMPLOYEE E1
WHERE E1.SAL_LEVEL = (SELECT MIN(E2.SAL_LEVEL)
                                FROM EMPLOYEE E2
                                WHERE E1.JOB_CODE = E2.JOB_CODE);
---
SELECT MIN(SAL_LEVEL) FROM EMPLOYEE WHERE JOB_CODE = 'J1';
SELECT MIN(SAL_LEVEL) FROM EMPLOYEE WHERE JOB_CODE = 'J4';
---
