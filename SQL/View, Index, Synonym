--VIEW CREATE 권한 부여
GRANT CREATE VIEW TO KH;

--VIEW 복사
CREATE VIEW EMP_VIEW
AS
SELECT EMP_ID, EMP_NAME, EMAIL, PHONE FROM EMPLOYEE;

--테이블 복사
CREATE TABLE EMP_COPY
AS
SELECT EMP_ID, EMP_NAME, EMAIL, PHONE FROM EMPLOYEE;

SELECT * FROM EMP_VIEW;     --VIEW 테이블을 참조함
SELECT * FROM EMP_COPY;     --TABLE 테이블을 그대로 복사
--차이는 무엇일까?
--VIEW 테이블을 참조하기 때문에 수정된 값을 반영한다
--하지만 COPY의 경우, 갱신을 하지 않으면 수정되지 않는다

UPDATE EMPLOYEE SET PHONE = '01000000000' WHERE EMP_ID = '200';
SELECT * FROM EMP_VIEW;     --반영이 되었다.
SELECT * FROM EMP_COPY;     -- 반영이 안 되었다.
ROLLBACK;

--그렇다면 뷰 테이블을 수정하게 되면 어떻게 될까? 
UPDATE EMP_VIEW SET PHONE = '01000000000' WHERE EMP_ID = '200';
SELECT * FROM EMP_VIEW;     --반영이 되었다.
SELECT * FROM EMPLOYEE;     --반영이 되었다.
SELECT * FROM EMP_COPY;     -- 반영이 안 되었다.
ROLLBACK;

GRANT SELECT ON kh.EMP_VIEW TO test01; --ADMIN에서 실행. TEST01 계정에 KH의 EMP_VIEW를 볼 수 있는 권한을 준다.
SELECT * FROM KH.EMP_VIEW;      --TEST01 계정으로 실행하면 실행 됨
SELECT * FROM KH.EMPLOYEE;      --존재하지 않는 테이블이라는 에러.

--KH 계정으로 다시 전환
CREATE VIEW EMP_VIEW
AS
SELECT EMP_NAME, EMAIL FROM EMPLOYEE;       --같은 이름을 갖고 있는 VIEW가 있기 때문에 CREATE 거부.

--REPLACE
CREATE OR REPLACE VIEW EMP_VIEW
AS
SELECT EMP_NAME, EMAIL FROM EMPLOYEE;       --같은 이름을 갖고 있는 VIEW가 있으면 대체, 없으면 생성

--VIEW 옵션 : CREATE OR REPLACE / FORCE(NO FORCE) / WITH CHECK OPTION / WITH READ ONLY
--WITH CHECK OPTION은 해당 칼럼 값의 수정 불가, WITH READ ONLY는 뷰 전체 수정 불가

--SEQUENCE
CREATE SEQUENCE SEQ_ID
START WITH 100      --시작값
INCREMENT BY 1      --증가값
MAXVALUE 10000      --최대값
NOCYCLE     --10000 이후 증가하지 않고 오류
NOCACHE;        -- 캐쉬 사용 안 함

SELECT SEQ_ID.NEXTVAL FROM DUAL;    -- 증가
SELECT SEQ_ID.CURRVAL FROM DUAL;

---
CREATE TABLE SEQ_TBL (
    MEMBER_NO NUMBER PRIMARY KEY,
    MEMBER_NAME VARCHAR2 (20) UNIQUE,
    MEMBER_PW VARCHAR2(30) NOT NULL
);
CREATE SEQUENCE SEQ_TEST
START WITH 1
INCREMENT BY 2
MAXVALUE 3
NOCYCLE
NOCACHE;

INSERT INTO SEQ_TBL VALUES (SEQ_TEST.NEXTVAL, 'USER01', '1234');
INSERT INTO SEQ_TBL VALUES (SEQ_TEST.NEXTVAL, 'USER02', '2345');
INSERT INTO SEQ_TBL VALUES (SEQ_TEST.NEXTVAL, 'USER03', '3456'); -- ERORR
SELECT * FROM SEQ_TBL;

ALTER SEQUENCE SEQ_TEST
INCREMENT BY 10 -- START 값은 수정이 불가능하다. 삭제하고 다시 만들어야 함
MAXVALUE 1000
NOCYCLE
NOCACHE;

INSERT INTO SEQ_TBL VALUES (SEQ_TEST.NEXTVAL, 'USER03', '3456');
SELECT * FROM SEQ_TBL; -- 기존에 세던 값에서부터 시작이 된다.
INSERT INTO SEQ_TBL VALUES (SEQ_TEST.NEXTVAL, 'USER04', '4567');
SELECT * FROM SEQ_TBL;
INSERT INTO SEQ_TBL VALUES (SEQ_TEST.NEXTVAL, 'USER04', '4567'); --UNIQUE 값이라 ERROR 발생
INSERT INTO SEQ_TBL VALUES (SEQ_TEST.NEXTVAL, 'USER05', '5678'); --그러나 NEXTVAL은 COUNT 된다
SELECT * FROM SEQ_TBL;

--------INDEX--------
CREATE INDEX EMP_IDD_NDD ON EMPLOYEE (EMP_NAME, EMP_NO, HIRE_DATE);

SELECT EMP_NAME, EMP_NO, HIRE_DATE FROM EMPLOYEE;       --F10을 눌러 OBJECT_NAME을 보면 EMP_IDD_NDD인 것을 볼 수 있음 (INDEX를 사용하고 있는 것/)
DROP INDEX EMP_IDD_NDD;
SELECT EMP_NAME, EMP_NO, HIRE_DATE FROM EMPLOYEE;       --DROP 후 보게 되면 EMPLOYEE로 뜬다

-----SYNONYM

GRANT CREATE SYNONYM TO KH;                 --권한 부여
CREATE SYNONYM EMP FOR EMPLOYEE;        --EMP라는 SYNONYM을 만들건데, EMPLOYEE를 줄인거야.
SELECT * FROM EMP;                                  --EMPLOYEE 대신 EMP를 입력하면 된다

--TEST01계정
GRANT SELECT ON KH.EMPLOYEE TO TEST01;  --ADMIN에서 실행
SELECT * FROM kh.EMPLOYEE;                      --TEST01에서 실행
SELECT * FROM KH.EMP;                               --TEST01에서도 실행 됨. 약자를 붙여줌녀 SYNONYM도 됨

GRANT SELECT ON KH.DEPARTMENT TO TEST01;

CREATE PUBLIC SYNONYM DEPT1234 FOR KH.DEPARTMENT;   --ADMIN

SELECT * FROM DEPT1234; -- TEST01 KH.DEPT1234가 아닌 DEPT1234로 해도 됨
DROP PUBLIC SYNONYM DEPT1234;       --SYNONYM 삭제

-----------------------------
---실습문제---
----- KHTEST 계정 생성 및 권한 부여 ------
CREATE USER KHTEST IDENTIFIED BY 1234
GRANT CONNECT, RESOURCE TO KHTEST;
GRANT CREATE VIEW TO KHTEST;
GRANT CREATE SYNONYM TO KHTEST;

---테이블 생성
CREATE TABLE MEMBER(
    MEMBER_NO NUMBER PRIMARY KEY,
    MEMBER_USERID VARCHAR2(20) NOT NULL,
    MEMBER_USERPWD CHAR (20) NOT NULL,
    MEMBER_NICKNAME VARCHAR2(20) NOT NULL,
    MEMBER_GENDER CHAR(3) NOT NULL,
    MEMBER_EMAIL VARCHAR2(30) NOT NULL,
    CHECK( MEMBER_GENDER IN ('남', '여')), UNIQUE(MEMBER_USERID), UNIQUE(MEMBER_NICKNAME)
);


CREATE TABLE BOARD(
    BOARD_NO NUMBER PRIMARY KEY,
    BOARD_TITLE VARCHAR2(20) NOT NULL,
    BOARD_CONTENT VARCHAR2(200) NOT NULL,
    BOARD_WRITEDATE DATE NOT NULL,
    BOARD_NICKNAME VARCHAR2(20) NOT NULL,
    FOREIGN KEY (BOARD_NICKNAME) REFERENCES MEMBER(MEMBER_NICKNAME)
);

---COMMENT 생성
COMMENT ON COLUMN MEMBER.MEMBER_NO IS '회원고유순번';
COMMENT ON COLUMN MEMBER.MEMBER_USERID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_USERPWD IS '회원비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NICKNAME IS '회원닉네임';
COMMENT ON COLUMN MEMBER.MEMBER_GENDER IS '회원성별';
COMMENT ON COLUMN MEMBER.MEMBER_EMAIL IS '회원이메일';

COMMENT ON COLUMN BOARD.BOARD_NO IS '글번호';
COMMENT ON COLUMN BOARD.BOARD_TITLE IS '글제목';
COMMENT ON COLUMN BOARD.BOARD_CONTENT IS '글내용';
COMMENT ON COLUMN BOARD.BOARD_WRITEDATE IS '글작성시간';
COMMENT ON COLUMN BOARD.BOARD_NICKNAME IS '글작성자';

--1. 필요한 SEQUENCE 객체 만들기

CREATE SEQUENCE SEQ_MEMBER
START WITH 1000
INCREMENT BY 1
MAXVALUE 1000000
NOCYCLE
NOCACHE;

CREATE SEQUENCE SEQ_BOARD
START WITH 1
INCREMENT BY 1
MAXVALUE 500000
NOCYCLE
NOCACHE;

--2. 회원번호, 회원닉네임, 회원이메일, 회원 작성글 제목을 볼 수 있는 VIEW 만들기

CREATE VIEW BOARD_VIEW AS
SELECT MEMBER_NO, MEMBER_NICKNAME, MEMBER_EMAIL, BOARD_TITLE FROM MEMBER JOIN BOARD ON(BOARD_NICKNAME = MEMBER_NICKNAME);

SELECT * FROM BOARD_VIEW;

--3. MEMBER와 BOARD 테이블을 M과 B로도 검색할 수 있게 만들기
CREATE SYNONYM M FOR MEMBER;
CREATE SYNONYM B FOR BOARD;

--테스트 데이터 넣기
INSERT INTO MEMBER VALUES (SEQ_MEMBER.NEXTVAL, 'ID1234', 'PW1234', 'NICK01', '남', 'ASDF@NAVER.COM');
INSERT INTO MEMBER VALUES (SEQ_MEMBER.NEXTVAL, 'ID2345', 'PW2345', 'NICK02', '여', 'SDFG@NAVER.COM');
INSERT INTO MEMBER VALUES (SEQ_MEMBER.NEXTVAL, 'ID3456', 'PW3456', 'NICK03', '여', 'DFGH@NAVER.COM');
INSERT INTO MEMBER VALUES (SEQ_MEMBER.NEXTVAL, 'ID4567', 'PW4567', 'NICK04', '남', 'FGHJ@NAVER.COM');
INSERT INTO MEMBER VALUES (SEQ_MEMBER.NEXTVAL, 'ID5678', 'PW5678', 'NICK04', '여', 'FGHJ@NAVER.COM'); --ERROR
INSERT INTO MEMBER VALUES (SEQ_MEMBER.NEXTVAL, 'ID5678', 'PW5678', 'NICK05', '여', 'QWER@NAVER.COM');

INSERT INTO BOARD VALUES (SEQ_BOARD.NEXTVAL, 'TITLE01', 'CONTENT01', SYSDATE, 'NICK01');
INSERT INTO BOARD VALUES (SEQ_BOARD.NEXTVAL, 'TITLE02', 'CONTENT02', SYSDATE, 'NICK02');
INSERT INTO BOARD VALUES (SEQ_BOARD.NEXTVAL, 'TITLE03', 'CONTENT04', SYSDATE, 'NICK03');
INSERT INTO BOARD VALUES (SEQ_BOARD.NEXTVAL, 'TITLE04', 'CONTENT04', SYSDATE, 'NICK04');
INSERT INTO BOARD VALUES (SEQ_BOARD.NEXTVAL, 'TITLE05', 'CONTENT05', SYSDATE, 'NICK06'); --ERROR
INSERT INTO BOARD VALUES (SEQ_BOARD.NEXTVAL, 'TITLE05', 'CONTENT05', SYSDATE, 'NICK05');

--조회
SELECT * FROM M;        -
SELECT * FROM B;
SELECT * FROM BOARD_VIEW;
