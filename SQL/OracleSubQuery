--SUBQUERY

--서브 쿼리를 사용하지 않을 시,
SELECT AVG(SALARY) FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3040000;

--서브 쿼리를 사용할 시,
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > (SELECT AVG(SALARY) 
                        FROM EMPLOYEE);

-- 예제 : 전지연 직원의 관리자 이름을 출력
--1) 전지연 직원의 MANAGER_ID를 구한다
--2) 구한 값을 바탕으로 이름을 출력한다.

--1) 
SELECT MANAGER_ID
FROM EMPLOYEE
WHERE EMP_NAME = '전지연';

--2)
SELECT EMP_NAME
FROM EMPLOYEE
WHERE EMP_ID = (SELECT MANAGER_ID
                                FROM EMPLOYEE
                                WHERE EMP_NAME = '전지연');
                                
--예제1) 윤은해와 급여가 같은 사원들을 검색, 사원번호와 이름, 급여를 출력. 단 윤은해는 출력x
SELECT 
    EMP_ID 사원번호, 
    EMP_NAME 이름,
    SALARY 급여
FROM
    EMPLOYEE
WHERE SALARY = (SELECT SALARY
                        FROM EMPLOYEE
                        WHERE EMP_NAME = '윤은해') 
                        AND EMP_NAME != '윤은해';

--예제2) EMPLOYEE 테이블에서 급여가 가장 많은 사람과 가장 적은 사람의 사번, 이름, 급여 출력
SELECT
    EMP_ID 사번,
    EMP_NAME 이름,
    SALARY 급여
FROM 
    EMPLOYEE
WHERE SALARY = (SELECT MAX(SALARY)
                        FROM EMPLOYEE) OR
         SALARY = (SELECT MIN(SALARY)
                       FROM EMPLOYEE);

--예제3) D1, D2 부서에서 근무하는 사원들 중, 기본 급여가 D5 부서의 평균 월급보다 많은 사람들의 부서번호, 사번, 이름, 월급 출력
SELECT
    DEPT_CODE 부서번호,
    EMP_ID 사번,
    EMP_NAME 이름,
    SALARY 월급
FROM
    EMPLOYEE
WHERE
    DEPT_CODE IN ('D1', 'D2') AND 
    SALARY > (SELECT AVG(SALARY)
                    FROM EMPLOYEE
                    WHERE DEPT_CODE = 'D5');
                    
--다중행 서브쿼리 (비교연산자 사용이 불가, IN/NOT IN/ANY/ALL/EXIST 사용 가능)
--송종기가 속한 부서의 사원정보 출력 (전체 정보)
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE
                            FROM EMPLOYEE
                            WHERE EMP_NAME = '송종기');

--송종기 또는 박나라가 속한 부서의 사원정보 출력 (전체 정보)
--(1)
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE
                            FROM EMPLOYEE
                            WHERE EMP_NAME = '송종기')
                            OR
        DEPT_CODE = (SELECT DEPT_CODE
        FROM EMPLOYEE
        WHERE EMP_NAME = '박나라');
--(2)
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE IN ((SELECT DEPT_CODE
                            FROM EMPLOYEE
                            WHERE EMP_NAME = '송종기')
                            , (SELECT DEPT_CODE
                            FROM EMPLOYEE
                            WHERE EMP_NAME = '박나라'));

--(3) 여러 ROW를 해당하는 값을 수행할 때. (비교연산자를 사용할 수 없다)
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE IN (SELECT DEPT_CODE
                                FROM EMPLOYEE
                                WHERE EMP_NAME IN ('송종기', '박나라'));
                                

-- IN / NOT IN / ANY / ALL / EXIST
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > ANY(2000000, 5000000); -- SALARY>2000000 OR SALARY>5000000랑 같은 의미
-- ANY : 최소값보다 크면 (큰 영역을 갖고 있는 것을 택해야 한다)
-- ALL : AND 연산자라고 생각하면 된다. 큰 값보다 크면. (좁은 영역을 갖고 있는 것을 택한다)
-- EXISTS : 수행 결과가 존재시, TRUE 값 반환. 출력 값이 중요한 것이 아님

SELECT EMP_NAME, MANAGER_ID, BONUS FROM EMPLOYEE E
WHERE EXISTS (SELECT EMP_NAME
                    FROM EMPLOYEE M
                    WHERE NVL(M.BONUS,0)>0.3);

-- 부서별 최고 급여를 받는 직원의 이름, 직급, 부서, 급여 조회
--1) 부서별 최고 급여
SELECT MAX(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT 
    EMP_NAME,
    JOB_NAME,
    DEPT_TITLE,
    SALARY
FROM
    EMPLOYEE
JOIN JOB USING (JOB_CODE)
JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
WHERE SALARY IN (SELECT MAX(SALARY)
                        FROM EMPLOYEE
                        GROUP BY DEPT_CODE);
    
--다중열
--퇴사한 여직원과 같은 부서, 같은 직급에 해당하는 사원의 이름, 직급, 부서 출력

--1) 퇴사한 여직원의 직급, 부서 조회
SELECT
    JOB_CODE,
    DEPT_CODE
FROM
    EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1)=2 AND ENT_YN='Y';

SELECT 
    EMP_NAME,
    DEPT_CODE,
    JOB_CODE
FROM
    EMPLOYEE
WHERE (DEPT_CODE, JOB_CODE) --각각 위치에 맞는 열 값을 비교한다.
    IN (SELECT
            DEPT_CODE,
            JOB_CODE                                                    
        FROM
            EMPLOYEE
        WHERE SUBSTR(EMP_NO,8,1)=2 AND ENT_YN='Y');    

    
