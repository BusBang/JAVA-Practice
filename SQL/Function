---------------------------------------------------------------
--20200225--
----------------

--LENGTH : 문자열 길이 반환
SELECT EMP_NAME, EMAIL, LENGTH(EMP_NAME), LENGTH( EMAIL)
FROM EMPLOYEE;

--LENGTHB : 문자열 바이트 수 반환 (오라클 EE는 한글을 3BYTE로 반환한다)
SELECT EMP_NAME, LENGTHB(EMP_NAME), EMAIL, LENGTHB(EMAIL)
FROM EMPLOYEE;

--INSTR : 지정한 문자(열)의 위치 반환
SELECT INSTR('HELLO WORLD HI HIGH', 'H', 1, 1)   --헬로 월드 하이 하이 에서 H를 찾는데, 첫 번째 글자부터 첫 번째 만나는 H를 반환 
FROM DUAL;

SELECT INSTR('HELLO WORLD HI HIGH', 'H', 1, 2)   --헬로 월드 하이 하이 에서 H를 찾는데, 첫 번째 글자부터 첫 번째 만나는 H를 반환 
FROM DUAL;

SELECT INSTR('HELLO WORLD HI HIGH', 'H', -1, 1)   --19
FROM DUAL;

SELECT INSTR('HELLO WORLD HI HIGH', 'H', -1, 2)   --헬로 월드 하이 하이 에서 H를 찾는데, 제일 뒷 글자부터 첫 번째 만나는 H를 반환 
FROM DUAL;

SELECT INSTR('HELLO WORLD HI HIGH', 'H', 2, 1)   --헬로 월드 하이 하이 에서 H를 찾는데, 첫 번째 글자부터 첫 번째 만나는 H를 반환 
FROM DUAL;

--
SELECT INSTR(EMAIL, '@', 1, 1)
FROM EMPLOYEE;

SELECT INSTR(EMAIL, '@', -1,1)
FROM EMPLOYEE;

--LPAD / RPAD : 왼/오른쪽에 문자를 채움
SELECT LPAD(EMAIL, 20, '#') FROM EMPLOYEE;
SELECT RPAD(EMAIL, 20, '#') FROM EMPLOYEE;
--그렇다면 더 짧은 글자는 ? --문자를 짜름
SELECT LPAD(EMAIL, 10, '#') FROM EMPLOYEE; 

--LTRIM/RTRIM 왼쪽/오른쪽부터 해당하는 문자열을 삭제함
SELECT '   KH' FROM DUAL;
SELECT LTRIM('   KH', '   ') FROM DUAL; --KH
SELECT RTRIM('   KH', '   ') FROM DUAL; --   KH
SELECT LTRIM('000123456', '0') FROM DUAL; --123456
SELECT LTRIM('12300KH','0') FROM DUAL; --12300KH
SELECT LTRIM('ACABACCKH', 'ABC') FROM DUAL; --KH
SELECT LTRIM('198874368253KH', '123456789') FROM DUAL; --KH
SELECT RTRIM(LTRIM('1234645KH12384785', '123456789'), '123456789') FROM DUAL;
--TRIM 양쪽(왼/오른쪽) 문자열 삭제
SELECT TRIM('Z' FROM 'ZZZKHZZZ') FROM DUAL; --KH
SELECT TRIM(BOTH 'Z' FROM 'ZZZKHZZZ') FROM DUAL; --KH
SELECT TRIM(LEADING'Z' FROM 'ZZZKHZZZ') FROM DUAL; --KHZZZ
SELECT TRIM(TRAILING'Z' FROM 'ZZZKHZZZ') FROM DUAL; --ZZZKH

-- 실습 문제 1
-- Hello KH Java 문자열을 Hello KH 가 출력되게 하여라.
SELECT RTRIM('Hello KH Java', ' Java')
FROM DUAL;

-- 실습 문제 2
-- Hello KH Java 문자열을 KH Java 가 출력되게 하여라.
SELECT LTRIM('Hello KH Java', 'Hello ')
FROM DUAL;


-- 실습 문제 3 (TRIM으로 해보세요)
-- DEPARTMENT 테이블에서 DEPT_TITLE을 출력하여라
-- 이때, 마지막 부 글자를 빼고 출력되도록 하여라 / ex)회계관리부 -> 회계관리
select TRIM(TRAILING '부' FROM dept_title)
from department;


-- 실습 문제 4
-- 다음문자열에서 앞뒤 모든 숫자를 제거하세요.
-- '982341678934509hello89798739273402'
SELECT LTRIM(RTRIM('982341678934509hello89798739273402', '1234567890'),'1234567890')
FROM DUAL;

--SUBSTR : 문자열의 시작점을 정해 시작점부터 길이만큼을 반환
SELECT 'SHOWMETHEMONEY' FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY', 5, 2) FROM DUAL; --ME
SELECT SUBSTR('SHOWMETHEMONEY', 5) FROM DUAL; --METHEMONEY
SELECT SUBSTR('SHOWMETHEMONEY', -8,3) FROM DUAL; --THE
SELECT SUBSTR('SHOW ME THE MONEY', -12,2) FROM DUAL; --ME

----1. 사원명에서 성만 중복없이 사전 순으로 출력하세요.
SELECT DISTINCT SUBSTR(EMP_NAME, 1, 1) AS 성
FROM EMPLOYEE
ORDER BY 성;

---2. EMPLOYEE TABLE에서 남자만,
---사원 번호, 사원명, 주민번호, 연봉을 출력하ㅔㅅ요
-- 주민번호의 뒷 6자리는 *처리

SELECT 
    EMP_ID AS 사원번호, 
    EMP_NAME AS 사원명,
    RPAD(SUBSTR(EMP_NO,1,7),14,'*') AS 주민번호, 
    SALARY*12 AS 연봉
FROM EMPLOYEE
WHERE EMP_NO LIKE '%-1%';

--LOWER/UPPER/INITCAP : 소문자, 대문자, 첫글자대문자
SELECT LOWER('Welcome To My World') From DUAL;
SELECT UPPER('Welcome To My World') From DUAL;
SELECT INITCAP('welcome to my world') FROM DUAL;

--CONCAT (2개 문자열 합치기)
SELECT CONCAT ('ABCD','가나다라') FROM DUAL;

--REPLACE 
SELECT REPLACE('ABCDEFG', 'DEF' , '한글') FROM DUAL;

--3. EMPLOYEE 테이블의 모든 직원의 이름, 주민번호, EMAIL 출력.
--단, 출력시 EMAIL은 kh.or.kr 에서 iei.or.kr로 변경하여 출력.
SELECT 
    EMP_NAME 이름, 
    EMP_NO 주민번호, 
    REPLACE(EMAIL, 'kh.or.kr', 'iei.or.kr') AS 이메일
FROM EMPLOYEE;

----ABS : 절댓값
SELECT ABS(-10) FROM DUAL;
--MOD : 나머지 연산
SELECT MOD(10,2) FROM DUAL; --0
SELECT MOD(10,3) FROM DUAL; --1
SELECT MOD(10,4) FROM DUAL; --2
--ROUND 반올림
SELECT ROUND (126.456) FROM DUAL; --126
SELECT ROUND (126.456,2) FROM DUAL; -- 126.46
SELECT ROUND (126.456,1) FROM DUAL; -- 126.5
SELECT ROUND (126.456,-1) FROM DUAL; -- 130

--FLOOR 버림
SELECT FLOOR(126.55) FROM DUAL;
--CEIL 올림
SELECT CEIL(126.15) FROM DUAL;

--SYSDATE :오늘날짜
SELECT SYSDATE FROM DUAL;
--그 외 현재 시간을 알 수 있는 명령어
SELECT
    SYSDATE,
    CURRENT_DATE,
    LOCALTIMESTAMP, --시분초 포함
    CURRENT_TIMESTAMP --시분초, 지역 포함
FROM DUAL;

--MONTHS_BETWEEN : 두 날짜간 몇 달이 차이나는지
SELECT EMP_NAME, FLOOR(MONTHS_BETWEEN(SYSDATE, HIRE_DATE))
FROM EMPLOYEE;

--ADD_MONTHS : 월 추가하기
SELECT EMP_NAME, HIRE_DATE , ADD_MONTHS(HIRE_DATE, 3) FROM EMPLOYEE;

--동건이의 재입대!
--복무기간은 1년 6개월 (18개월)
--1. 전역하는 날짜
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 18)-1 FROM DUAL;

--2. 먹어야하는 짬밥 수 (하루 3끼)
SELECT (ADD_MONTHS(SYSDATE, 18)-SYSDATE)*3 AS 먹어야하는짬밥
FROM DUAL;

--NEXT_DAY //현재날짜 20/02/25
SELECT SYSDATE, NEXT_DAY(SYSDATE, '월요일') FROM DUAL; --20/03/02
SELECT SYSDATE, NEXT_DAY(SYSDATE, '수요일') FROM DUAL; --20/02/26
-- 1일요일 2월요일 7토요일
SELECT SYSDATE, NEXT_DAY(SYSDATE, 1) FROM DUAL; --20/03/01 일요일
SELECT SYSDATE, NEXT_DAY(SYSDATE, 2) FROM DUAL; --20/03/02 월요일
SELECT SYSDATE, NEXT_DAY(SYSDATE, 7) FROM DUAL; --20/02/29 토요일

--LAST_DAY //해당 달의 마지막 날짜
SELECT SYSDATE, LAST_DAY(SYSDATE+10) FROM DUAL; --20/03/31

--EXTRACT : 현재 날짜에서 년/월/일을 추출
SELECT 
    EXTRACT(YEAR FROM SYSDATE),
    EXTRACT(MONTH FROM SYSDATE),
    EXTRACT(DAY FROM SYSDATE)
FROM DUAL;


/*
실습문제
EMPLOYEE 테이블에서 사원의 이름, 입사일, 년차를 출력.
단, 입사일은 YYYY년 M월 D일로 출력
년차 출력은 소수점일 경우, 올림으로 하여 출력
(26.144->27년차)
(출력시 정렬은 입사일 기준으로 오름차순)
*/
SELECT 
    EMP_NAME AS 사원이름,
    CONCAT(EXTRACT(YEAR FROM HIRE_DATE),'년')||
    CONCAT(EXTRACT(MONTH FROM HIRE_DATE),'월')||
    CONCAT(EXTRACT(DAY FROM HIRE_DATE),'일') AS 입사일,
    CEIL((SYSDATE-HIRE_DATE)/365) AS 연차
FROM
    EMPLOYEE
ORDER BY
    HIRE_DATE ASC;

--형변환
--TO_CHAR : 다른 형식을 문자열 형식으로 변환
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL; -- 2020/02/25
SELECT TO_CHAR(SYSDATE, 'YY-MM-DD') FROM DUAL; -- 20/02/25
SELECT TO_CHAR(SYSDATE, 'YY/MM/DD/DAY') FROM DUAL; -- 20/02/25/화요일
SELECT TO_CHAR(SYSDATE, 'YY/MM/DD/DY') FROM DUAL; -- 20/02/25/화
SELECT TO_CHAR(SYSDATE, 'YY/MM/DD/PMHH"시"MI"분"SS"초"') FROM DUAL; -- 20/02/25/오후02시47분00초
SELECT TO_CHAR(SYSDATE, 'YY/MM/DD/HH24"시"MI"분"SS"초"') FROM DUAL; -- 20/02/25/14시47분00초
SELECT TO_CHAR(SYSDATE, 'FMYY/MM/DD/PMHH"시"MI"분"SS"초"') FROM DUAL; -- 20/2/25/오후02시48분5초  ----------------0을 빼준다

SELECT 
    TO_CHAR(5000000,'999,999'), --######## 자리수가 부족하면 안 됨
    TO_CHAR(5000000,'999,999,999'), --5,000,000
    TO_CHAR(5000000,'000,000,000'), --005,000,000
    TO_CHAR(5000000,'$999,999,999'), --$5,000,000
    TO_CHAR(5000000,'L999,999,999') --\5,000,000
FROM DUAL;

-- TO_DATE : 다른 타입을 날짜 타입으로 변경
SELECT TO_DATE(20000101, 'YYYYMMDD') FROM DUAL; --2000/01/01
SELECT TO_CHAR(TO_DATE(20000101, 'YYYYMMDD'), 'YYYY/MM/DD HH24:MI:SS') FROM DUAL;
SELECT TO_DATE(20120101, 'YYMMDD') FROM DUAL; -- 12/01/01

--EMPLOYEE 테이블에서
-- 2000년도 이후에 입사한 사원의 이름과 입사일 출력
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE>=TO_DATE(2000,'YYYY');

--TO_NUMBER
SELECT TO_NUMBER('5,000,000','9,999,999') FROM DUAL;
SELECT TO_NUMBER('123A') FROM DUAL; -- 문자열 작동 안 함
SELECT TO_NUMBER('5,000,000','999,999') FROM DUAL; -- 자리수가 부족하면 ERROR 발생
SELECT '1000'+'100' FROM DUAL; --자바에서는 1000100. 오라클은 1100
SELECT '1000A'+'100' FROM DUAL; --ERROR. 문자열을 숫자로 변경하지 못하기 때문에. (꼭 숫자만 더해야한다)

--NVL : NULL처리 함수 NVL( IF(NULL), 대체값)
SELECT BONUS, NVL(BONUS, 0) --BONUS에 NULL이 있다면, 0으로 반환.
FROM EMPLOYEE;
SELECT EMP_NAME, (SALARY+ (SALARY*NVL(BONUS,0)))*12 총수령액
FROM EMPLOYEE;

--DECODE 함수 DECODE(변수, 조건1, 결과1, 조건2, 결과2)
--여러가지 경우에 선택할 수 있는 기능을 제공 (일치하는 값)
SELECT 
    EMP_NAME, 
    EMP_NO, 
    DECODE(SUBSTR(EMP_NO,8,1),'1','남자','2','여자')
FROM EMPLOYEE;

-- CASE 선택함수 (CASE WHEN 조건 THEN 결과 ... ELSE 결과 END)
-- 여러가지 경우에 선택할 수 있는 기능을 제공 (범위 값 가능)
SELECT EMP_NAME, EMP_NO,
    CASE WHEN SUBSTR(EMP_NO, 8,1) = '1' THEN '남자'
            WHEN SUBSTR(EMP_NO, 8,1) = '2' THEN '여자'
            ELSE '미성년자' END AS 성별
FROM EMPLOYEE;

SELECT EMP_NAME, EMP_NO,
    CASE
        WHEN SUBSTR (EMP_NO,1,2)<65 THEN '60년대 초반'
        WHEN SUBSTR (EMP_NO,1,2)>=65 THEN '60년대 후반'
    END AS 연배
FROM EMPLOYEE
WHERE SUBSTR (EMP_NO,1,2) BETWEEN 60 AND 69;

---그룹함수 SUM AVG COUNT MAX, MIN
--NULL을 제외하니 꼭 NVL을 써주어야 한다.
--D5부서의 남사원의 SALARY 총 합 *************************
SELECT SUM(SALARY), FLOOR(AVG(SALARY))
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1)='1' AND DEPT_CODE='D5';

SELECT ROUND(AVG(NVL(BONUS,0)),2) 
FROM EMPLOYEE;

SELECT COUNT(*)
FROM EMPLOYEE; --23
SELECT COUNT(BONUS)
FROM EMPLOYEE; --9  --> 그룹함수는 NULL값을 제외한다
SELECT COUNT(NVL(BONUS,0))
FROM EMPLOYEE; --23 

SELECT MAX(SALARY), MIN(SALARY) FROM EMPLOYEE;
SELECT MAX(HIRE_DATE), MIN(HIRE_DATE) FROM EMPLOYEE; --날짜에도 사용할 수 있다.

/*
------ 작동하지 않음 -> COUNT는 한 개의 행만 반환하기 때문에 안 됨
SELECT EMP_NAME,
        COUNT(BONUS)
FROM EMPLOYEE;
*/

SELECT *
FROM EMPLOYEE;

--1. 직원명과 이메일 , 이메일 길이를 출력하시오.
SELECT 
    EMP_NAME 직원명,
    EMAIL 이메일,
    LENGTH(EMAIL) AS "이메일 길이"
FROM EMPLOYEE;

--2. 직원의 이름과 이메일 주소중 아이디 부분만 출력하시오.
SELECT
    EMP_NAME 직원명,
    SUBSTR(EMAIL,1,INSTR(EMAIL, '@')-1) 아이디
FROM EMPLOYEE;

--3. 60년생의 직원명과 년생, 보너스 값을 출력하시오. 그때 보너스 값이 null인 경우에는 0 이라고 출력 되게 만드시오.
SELECT
    EMP_NAME 직원명,
    SUBSTR(EMP_NO,1,2) 년생,
    NVL(BONUS,0) 보너스
FROM
    EMPLOYEE
WHERE
    SUBSTR(EMP_NO,1,2) BETWEEN 60 AND 69;

--4. '010' 핸드폰 번호를 쓰지 않는 사람의 수를 출력하시오 (뒤에 단위는 명을 붙이시오)
SELECT COUNT(*) || '명' AS "010아닌사람"
FROM EMPLOYEE
WHERE SUBSTR(PHONE,1,3) != '010';

--5. 직원명과 입사년월을 출력하시오. 단, 아래와 같이 출력되도록 만들어 보시오
--	    직원명		입사년월
--	ex) 전형돈		2012년12월
--	ex) 전지연		1997년 3월
SELECT 
    EMP_NAME AS 직원명,
    TO_CHAR(HIRE_DATE, 'FMYYYY"년"MM"월"') AS 입사년월
FROM EMPLOYEE;

--6. 직원명과 주민번호를 조회하시오
--	단, 주민번호 9번째 자리부터 끝까지는 '*' 문자로 채워서출력 하시오.
--	ex) 홍길동 771120-1******

SELECT 
    EMP_NAME AS 직원명,
    REPLACE(EMP_NO,SUBSTR(EMP_NO, 9),'******') AS 주민번호
FROM EMPLOYEE;


--7. 직원명, 직급코드, 연봉(원) 조회하시오.
--  단, 연봉은 ￦57,000,000 으로 표시되게 함
--     연봉은 보너스포인트가 적용된 1년치 급여임
SELECT
    EMP_NAME 직원명,
    NVL(DEPT_CODE, '없음') 직급코드,
    TO_CHAR(SALARY*(1+NVL(BONUS,0))*12, 'L999,999,999,999') AS 연봉
FROM
    EMPLOYEE;

--8. 부서코드가 D5, D9인 직원들 중에서 2004년도에 입사한 직원의 사번 사원명 부서코드 입사일을 출력하시오.
SELECT  
    EMP_ID 사번,
    EMP_NAME 사원명,
    DEPT_CODE 부서코드,
    HIRE_DATE 입사일
FROM EMPLOYEE
WHERE (DEPT_CODE IN ('D5', 'D9')) AND HIRE_DATE BETWEEN '20040101' AND '20041231';

--9. 직원명, 입사일, 오늘까지의 근무일수 조회 
--	* 주말도 포함 , 소수점 아래는 버림
SELECT
    EMP_NAME 직원명,
    HIRE_DATE 입사일,
    FLOOR(SYSDATE-HIRE_DATE) 근무일수
FROM EMPLOYEE;

--10. 모든 직원의 나이 중 가장 많은 나이와 가장 적은 나이를 출력 하여라. (나이만 출력)
SELECT 
    101+TO_CHAR(SYSDATE,'YY') - MAX(SUBSTR(EMP_NO,1,2)) 적은사람,
    101+TO_CHAR(SYSDATE,'YY') - MIN(SUBSTR(EMP_NO,1,2)) 많은사람
FROM EMPLOYEE;

--11.  회사에서 야근을 해야 되는 부서를 발표하여야 한다.
-- 부서코드가 D5,D6,D9  야근, 그외는 야근없음 으로 출력되도록 하여라. 
-- 출력 값은 이름,부서코드,야근유무 (부서코드 기준 오름차순 정렬함.)
--   (부서코드가 null인 사람도 야근없음 임)
   
SELECT 
    EMP_NAME 이름,
    DEPT_CODE 부서코드,
    CASE
        WHEN DEPT_CODE IN('D5', 'D6', 'D9') THEN '야근'
        ELSE '야근없음' END AS 야근유무
FROM EMPLOYEE
ORDER BY 2;

--12. 직원명, 부서코드, 생년월일, 나이 조회
--   단, 생년월일은 주민번호에서 추출해서, 
--   ㅇㅇ년 ㅇㅇ월 ㅇㅇ일로 출력되게 함.
--   나이는 주민번호에서 추출해서 날짜데이터로 변환한 다음, 계산함
--	* 주민번호가 이상한 사람들은 제외시키고 진행 하도록(200,201,214 번 제외)
--	* HINT : NOT IN 사용


SELECT
    EMP_NAME 직원명,
    DEPT_CODE 부서코드,
    TO_CHAR(TO_DATE(SUBSTR(EMP_NO,1,6)),'YY"년"MM"월"DD"일"') 생년월일,
    FLOOR((SYSDATE-TO_DATE(SUBSTR(EMP_NO,1,6)))/365)+1 AS 나이 
FROM EMPLOYEE
WHERE EMP_ID NOT IN (200, 201, 214);

--13. 직원들의 입사일로 부터 년도만 가지고, 각 년도별 입사인원수를 구하시오.
--  아래의 년도에 입사한 인원수를 조회하시오. 마지막으로 전체직원수도 구하시오
--  => to_char, decode, sum 사용
--	-------------------------------------------------------------------------
--	 1998년   1999년   2000년   2001년   2002년   2003년   2004년  전체직원수
--	-------------------------------------------------------------------------
SELECT
    NVL(SUM(DECODE(SUBSTR(TO_CHAR(HIRE_DATE,'YYYYMMDD'),1,4),'1998',1)),0) AS "1998년",
    NVL(SUM(DECODE(SUBSTR(TO_CHAR(HIRE_DATE,'YYYYMMDD'),1,4),'1999',1)),0) AS "1999년",
    NVL(SUM(DECODE(SUBSTR(TO_CHAR(HIRE_DATE,'YYYYMMDD'),1,4),'2000',1)),0) AS "2000년",
    NVL(SUM(DECODE(SUBSTR(TO_CHAR(HIRE_DATE,'YYYYMMDD'),1,4),'2001',1)),0) AS "2001년",
    NVL(SUM(DECODE(SUBSTR(TO_CHAR(HIRE_DATE,'YYYYMMDD'),1,4),'2002',1)),0) AS "2002년",
    NVL(SUM(DECODE(SUBSTR(TO_CHAR(HIRE_DATE,'YYYYMMDD'),1,4),'2003',1)),0) AS "2003년",
    NVL(SUM(DECODE(SUBSTR(TO_CHAR(HIRE_DATE,'YYYYMMDD'),1,4),'2004',1)),0) AS "2004년",
    NVL(COUNT(HIRE_DATE),0) AS 전체직원수
FROM EMPLOYEE;

	
--14.  부서코드가 D5이면 총무부, D6이면 기획부, D9이면 영업부로 처리하시오.
--   단, 부서코드가 D5, D6, D9 인 직원의 정보만 조회함
--  => case 사용  부서코드 기준 오름차순 정렬함.

SELECT 
    EMP_ID 직원코드,
    EMP_NAME 직원명,
    EMP_NO 직원번호,
    CASE
        WHEN DEPT_CODE = 'D5' THEN '총무부'
        WHEN DEPT_CODE = 'D6' THEN '기획부'
        ELSE '영업부' END AS 부서
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D5', 'D6', 'D9')
ORDER BY DEPT_CODE;

